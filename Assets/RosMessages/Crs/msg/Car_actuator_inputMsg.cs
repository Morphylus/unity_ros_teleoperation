//Do not edit! This file was generated by Unity-ROS MessageGeneration.
using System;
using System.Linq;
using System.Collections.Generic;
using System.Text;
using Unity.Robotics.ROSTCPConnector.MessageGeneration;
using RosMessageTypes.Std;

namespace RosMessageTypes.Crs
{
    [Serializable]
    public class Car_actuator_inputMsg : Message
    {
        public const string k_RosMessageName = "crs_msgs/car_actuator_input";
        public override string RosMessageName => k_RosMessageName;

        //  This is a message to hold the control action that a car applies locally on the
        //  embedded system.
        // 
        //  The control action consists of the power supplied to the actuators, plus
        //  direction. On the cars, the following conventions hold:
        //  - The power is normalized in the range [-1, 1], where the extremes are the
        //    maximum amount of power that can be supplied to the actuator.
        //  - The sign denotes the direction that the torque is applied in: for driving,
        //    power > 0 means forward torque and for steering, power > 0 means turning the
        //    wheels to the left.
        public HeaderMsg header;
        //  The mode of the PWM signal that is sent to the actuator. The modes are:
        public const byte PWM_MODE_UNKNOWN = 0; //  unknown mode
        public const byte PWM_MODE_ON_FAST_DECAY = 1; //  driving with fast decay in down phase
        public const byte PWM_MODE_ON_SLOW_DECAY = 2; //  driving with slow decay in down phase
        public const byte PWM_MODE_COASTING = 3; //  HiZ coasting with no power
        public const byte PWM_MODE_BRAKING = 4; //  braking with no power
        public const byte PWM_MODE_DISABLED = 5; //  motor disabled
        //  Normalized input values for the steer and throttle actuators.
        public float throttle_input;
        //  [-1, 1]
        public float steer_input;
        //  [-1, 1]
        public byte throttle_pwm_mode;
        //  mode of the PWM signal that is sent to the throttle
        public byte steer_pwm_mode;
        //  mode of the PWM signal that is sent to the steer actuator
        public float throttle_current;
        //  [A] current on the throttle actuator (or NaN if not available)
        public float steer_current;
        //  [A] current on the steer actuator (or NaN if not available)

        public Car_actuator_inputMsg()
        {
            this.header = new HeaderMsg();
            this.throttle_input = 0.0f;
            this.steer_input = 0.0f;
            this.throttle_pwm_mode = 0;
            this.steer_pwm_mode = 0;
            this.throttle_current = 0.0f;
            this.steer_current = 0.0f;
        }

        public Car_actuator_inputMsg(HeaderMsg header, float throttle_input, float steer_input, byte throttle_pwm_mode, byte steer_pwm_mode, float throttle_current, float steer_current)
        {
            this.header = header;
            this.throttle_input = throttle_input;
            this.steer_input = steer_input;
            this.throttle_pwm_mode = throttle_pwm_mode;
            this.steer_pwm_mode = steer_pwm_mode;
            this.throttle_current = throttle_current;
            this.steer_current = steer_current;
        }

        public static Car_actuator_inputMsg Deserialize(MessageDeserializer deserializer) => new Car_actuator_inputMsg(deserializer);

        private Car_actuator_inputMsg(MessageDeserializer deserializer)
        {
            this.header = HeaderMsg.Deserialize(deserializer);
            deserializer.Read(out this.throttle_input);
            deserializer.Read(out this.steer_input);
            deserializer.Read(out this.throttle_pwm_mode);
            deserializer.Read(out this.steer_pwm_mode);
            deserializer.Read(out this.throttle_current);
            deserializer.Read(out this.steer_current);
        }

        public override void SerializeTo(MessageSerializer serializer)
        {
            serializer.Write(this.header);
            serializer.Write(this.throttle_input);
            serializer.Write(this.steer_input);
            serializer.Write(this.throttle_pwm_mode);
            serializer.Write(this.steer_pwm_mode);
            serializer.Write(this.throttle_current);
            serializer.Write(this.steer_current);
        }

        public override string ToString()
        {
            return "Car_actuator_inputMsg: " +
            "\nheader: " + header.ToString() +
            "\nthrottle_input: " + throttle_input.ToString() +
            "\nsteer_input: " + steer_input.ToString() +
            "\nthrottle_pwm_mode: " + throttle_pwm_mode.ToString() +
            "\nsteer_pwm_mode: " + steer_pwm_mode.ToString() +
            "\nthrottle_current: " + throttle_current.ToString() +
            "\nsteer_current: " + steer_current.ToString();
        }

#if UNITY_EDITOR
        [UnityEditor.InitializeOnLoadMethod]
#else
        [UnityEngine.RuntimeInitializeOnLoadMethod]
#endif
        public static void Register()
        {
            MessageRegistry.Register(k_RosMessageName, Deserialize);
        }
    }
}
